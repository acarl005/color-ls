// Generated by CoffeeScript 1.10.0
(function() {
  var BG, BW, _, _s, ansi, args, bold, colors, dirString, error1, extString, fg, fgc, filestats, fs, fw, groupName, j, len, linkString, listDir, listFiles, log, log_error, mediaTypes, months, nameString, ownerName, ownerString, p, path, pathstats, prof, ref, ref1, reset, rightsString, rwxString, since, sizeString, sort, sprintf, start, stats, time, timeString, token, username,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  start = Date.now();

  time = function(msg) {
    if (msg == null) {
      msg = '';
    }
    return console.log(msg + ' ' + (Date.now() - start));
  };

  ansi = require('ansi-256-colors');

  fs = require('fs');

  path = require('path');

  _s = require('underscore.string');

  _ = require('lodash');

  log = console.log;

  months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

  start = 0;

  token = {};

  since = function(t) {
    var diff;
    diff = process.hrtime(token[t]);
    return diff[0] * 1000 + diff[1] / 1000000;
  };

  prof = function() {
    var cmd, t;
    if (arguments.length === 2) {
      cmd = arguments[0];
      t = arguments[1];
    } else if (arguments.length === 1) {
      t = arguments[0];
      cmd = 'start';
    }
    start = process.hrtime();
    if (cmd === 'start') {
      return token[t] = start;
    } else if (cmd === 'end') {
      return since(t);
    }
  };

  prof('start', 'ls');

  bold = '\x1b[1m';

  reset = ansi.reset;

  fg = ansi.fg.getRgb;

  BG = ansi.bg.getRgb;

  fgc = function(i) {
    return ansi.fg.codes[i];
  };

  fw = function(i) {
    return ansi.fg.grayscale[i];
  };

  BW = function(i) {
    return ansi.bg.grayscale[i];
  };

  stats = {
    num_dirs: 0,
    num_files: 0,
    hidden_dirs: 0,
    hidden_files: 0,
    maxOwnerLength: 0,
    maxGroupLength: 0,
    brokenLinks: []
  };

  args = require('karg')("color-ls\n    paths         . ? the file(s) and/or folder(s) to display . **\n    bytes         . ? include size                    . = false \n    mdate         . ? include modification date       . = false              \n    owner         . ? include owner and group         . = false            \n    rights        . ? include rights                  . = false   \n    long          . ? include size, date, owner, rights . = false          \n    all           . ? show dot files                  . = false\n    dirs          . ? show only dirs                  . = false   \n    files         . ? show only files                 . = false    \n    size          . ? sort by size                    . = false \n    time          . ? sort by time                    . = false \n    kind          . ? sort by kind                    . = false \n    pretty        . ? pretty size and date            . = true\n    stats         . ? show statistics                 . = false . - i\n    icons         . ? show icons before folders       . = false . - I\n    recurse       . ? recurse into subdirs            . = false . - R\n    find          . ? filter with a regexp                      . - F\n    alphabetical  . ! don't group dirs before files   . = false . - A\n    \nversion      " + (require(__dirname + "/../package.json").version) + "    ");

  if (args.size) {
    args.files = true;
  }

  if (args.long) {
    args.bytes = true;
    args.mdate = true;
    args.owner = true;
    args.rights = true;
  }

  if (!(((ref = args.paths) != null ? ref.length : void 0) > 0)) {
    args.paths = ['.'];
  }

  colors = {
    'coffee': [bold + fgc(136), fgc(130)],
    'js': [bold + fg(4, 4, 0), fg(2, 2, 0)],
    'json': [bold + fg(4, 4, 0), fg(2, 2, 0)],
    'cson': [bold + fgc(136), fgc(130)],
    'jsx': [bold + fgc(14), fgc(6)],
    'plist': [bold + fg(4, 0, 4), fg(2, 0, 2)],
    'sh': [bold + fg(4, 0, 4), fg(2, 0, 2)],
    'bash': [bold + fg(4, 0, 4), fg(2, 0, 2)],
    'cpp': [bold + fg(4, 0, 4), fg(2, 0, 2)],
    'h': [bold + fg(4, 0, 4), fg(2, 0, 2)],
    'py': [bold + fg(0, 3, 0), fg(0, 1, 0)],
    'pyc': [fw(8), fw(5)],
    'rb': [bold + fg(5, 1, 0), fg(3, 0, 0)],
    'log': [fw(8), fw(5)],
    'swp': [fw(8), fw(5)],
    'md': [fgc(87), fgc(73)],
    'markdown': [fgc(87), fgc(73)],
    'html': [fgc(87), fgc(73)],
    'css': [fgc(219), fgc(207)],
    'scss': [fgc(219), fgc(207)],
    'tar': [fg(5, 0, 0), fg(3, 0, 0)],
    'gz': [fg(5, 0, 0), fg(3, 0, 0)],
    'zip': [fg(5, 0, 0), fg(3, 0, 0)],
    '_default': [fw(23), fw(12)],
    '_dir': [bold + BG(0, 0, 2) + fw(23), fg(1, 1, 5), fg(2, 2, 5)],
    '_.dir': [bold + BG(0, 0, 1) + fw(23), bold + BG(0, 0, 1) + fg(1, 1, 5), bold + BG(0, 0, 1) + fg(2, 2, 5)],
    '_link': {
      'arrow': fg(1, 0, 1),
      'path': fg(4, 0, 4),
      'broken': BG(5, 0, 0) + fg(5, 5, 0)
    },
    '_arrow': fw(1),
    '_header': [bold + BW(2) + fg(3, 2, 0), fw(4), bold + BW(2) + fg(5, 5, 0)],
    '_media': [fgc(141), fgc(54)],
    '_size': {
      b: fgc(20),
      kB: fgc(33),
      MB: fgc(81),
      GB: fgc(123)
    },
    '_users': {
      root: fg(5, 0, 2),
      "default": fg(0, 3, 3)
    },
    '_groups': {
      wheel: fg(3, 0, 0),
      staff: fg(0, 2, 0),
      admin: fg(2, 2, 0),
      "default": fg(2, 0, 2)
    },
    '_error': [bold + BG(5, 0, 0) + fg(5, 5, 0), bold + BG(5, 0, 0) + fg(5, 5, 5)]
  };

  mediaTypes = new Set(['png', 'gif', 'jpg', 'jpeg', 'ico', 'svg', 'webp', 'tiff', 'pxm', 'mp3', 'm4a', 'wav', 'webm', 'avi', 'wmv']);

  try {
    username = require('userid').username(process.getuid());
    colors['_users'][username] = fg(0, 4, 0);
  } catch (error1) {
    username = "";
  }

  log_error = function() {
    return log(" " + colors['_error'][0] + " " + bold + arguments[0] + (arguments.length > 1 && (colors['_error'][1] + [].slice.call(arguments).slice(1).join(' ')) || '') + " " + reset);
  };

  linkString = function(file) {
    return reset + colors['_link']['arrow'] + " â–º " + colors['_link'][(indexOf.call(stats.brokenLinks, file) >= 0) && 'broken' || 'path'] + fs.readlinkSync(file);
  };

  nameString = function(name, ext) {
    var key;
    key = mediaTypes.has(ext) ? "_media" : ext;
    return " " + colors[(colors[key] != null) && key || '_default'][0] + name + reset;
  };

  extString = function(ext) {
    var key;
    key = mediaTypes.has(ext) ? "_media" : ext;
    return colors[(colors[key] != null) && key || '_default'][1] + '.' + ext + reset;
  };

  dirString = function(name, ext) {
    var c;
    c = name && '_dir' || '_.dir';
    if (args.icons) {
      name = 'ðŸ“‚ ' + name;
    }
    return colors[c][0] + (name && (" " + name) || "") + (ext ? colors[c][1] + '.' + colors[c][2] + ext : "") + " ";
  };

  sizeString = function(stat) {
    var sizes;
    sizes = colors['_size'];
    if (stat.size < 1000) {
      if (args.pretty) {
        return sizes['b'] + _s.lpad(stat.size, 7) + " B ";
      } else {
        return sizes['b'] + _s.lpad(stat.size, 10) + " ";
      }
    } else if (stat.size < 1000000) {
      if (args.pretty) {
        return sizes['kB'] + _s.lpad((stat.size / 1000).toFixed(0), 7) + "kB ";
      } else {
        return sizes['kB'] + _s.lpad(stat.size, 10) + " ";
      }
    } else if (stat.size < 1000000000) {
      if (args.pretty) {
        return sizes['MB'] + _s.lpad((stat.size / 1000000).toFixed(1), 7) + "MB ";
      } else {
        return sizes['MB'] + _s.lpad(stat.size, 10) + " ";
      }
    } else {
      if (args.pretty) {
        return sizes['GB'] + _s.lpad((stat.size / 1000000000).toFixed(1), 7) + "GB ";
      } else {
        return sizes['GB'] + _s.lpad(stat.size, 10) + " ";
      }
    }
  };

  timeString = function(stat) {
    var col, d;
    d = new Date(stat.mtime);
    return fw(20) + (args.pretty ? _s.lpad(d.getDate(), 2) : _s.lpad(d.getDate(), 2, '0')) + fw(7) + '.' + (args.pretty ? fw(15) + months[d.getMonth()] + fw(7) + "'" : fw(15) + _s.lpad(d.getMonth() + 1, 2, '0') + fw(7) + "'") + fw(10) + d.getFullYear().toString().slice(-2) + " " + fw(20) + _s.lpad(d.getHours(), 2, '0') + (col = fw(7) + ':' + fw(15) + _s.lpad(d.getMinutes(), 2, '0') + (col = fw(7) + ':' + fw(10) + _s.lpad(d.getSeconds(), 2, '0') + " "));
  };

  ownerName = function(stat) {
    var error2;
    try {
      return require('userid').username(stat.uid);
    } catch (error2) {
      return stat.uid;
    }
  };

  groupName = function(stat) {
    var error2;
    try {
      return require('userid').groupname(stat.gid);
    } catch (error2) {
      return stat.gid;
    }
  };

  ownerString = function(stat, ownerColor, groupColor) {
    var grp, own;
    own = ownerName(stat);
    grp = groupName(stat);
    return ownerColor + _s.rpad(own, stats.maxOwnerLength) + " " + groupColor + _s.rpad(grp, stats.maxGroupLength);
  };

  rwxString = function(stat, i, color) {
    var mode;
    mode = stat.mode >> (i * 3);
    bold + color;
    return ((mode & 0x4) && 'r' || '-') + ((mode & 0x2) && 'w' || '-') + ((mode & 0x1) && 'x' || '-');
  };

  rightsString = function(stat, ownerColor, groupColor) {
    var group, other, user;
    user = rwxString(stat, 2) + " ";
    group = rwxString(stat, 1) + " ";
    other = rwxString(stat, 0) + " ";
    return BW(2) + " " + ownerColor + user + groupColor + group + fw(15) + other + reset;
  };

  sort = function(list, stats, exts) {
    var j, k, l, ref1, ref2, results, results1;
    if (exts == null) {
      exts = [];
    }
    l = _.zip(list, stats, (function() {
      results = [];
      for (var j = 0, ref1 = list.length; 0 <= ref1 ? j < ref1 : j > ref1; 0 <= ref1 ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this), exts.length > 0 && exts || (function() {
      results1 = [];
      for (var k = 0, ref2 = list.length; 0 <= ref2 ? k < ref2 : k > ref2; 0 <= ref2 ? k++ : k--){ results1.push(k); }
      return results1;
    }).apply(this));
    if (args.kind) {
      if (exts === []) {
        return list;
      }
      l.sort(function(a, b) {
        var d1, d2;
        if (a[3] > b[3]) {
          return 1;
        }
        if (a[3] < b[3]) {
          return -1;
        }
        if (args.time) {
          d1 = new Date(a[1].mtime);
          d2 = new Date(b[1].mtime);
          if (d1 > d2) {
            return 1;
          }
          if (d1 < d2) {
            return -1;
          }
        }
        if (args.size) {
          if (a[1].size > b[1].size) {
            return 1;
          }
          if (a[1].size < b[1].size) {
            return -1;
          }
        }
        if (a[2] > b[2]) {
          return 1;
        }
        return -1;
      });
    } else if (args.time) {
      l.sort(function(a, b) {
        var d1, d2;
        d1 = new Date(a[1].mtime);
        d2 = new Date(b[1].mtime);
        if (d1 > d2) {
          return 1;
        }
        if (d1 < d2) {
          return -1;
        }
        if (args.size) {
          if (a[1].size > b[1].size) {
            return 1;
          }
          if (a[1].size < b[1].size) {
            return -1;
          }
        }
        if (a[2] > b[2]) {
          return 1;
        }
        return -1;
      });
    } else if (args.size) {
      l.sort(function(a, b) {
        if (a[1].size > b[1].size) {
          return 1;
        }
        if (a[1].size < b[1].size) {
          return -1;
        }
        if (a[2] > b[2]) {
          return 1;
        }
        return -1;
      });
    }
    return _.unzip(l)[0];
  };

  listFiles = function(p, files) {
    var alph, d, dirs, dsts, exts, f, fils, fsts, j, k, len, len1, len2, m, results, results1;
    if (args.alphabetical) {
      alph = [];
    }
    dirs = [];
    fils = [];
    dsts = [];
    fsts = [];
    exts = [];
    if (args.owner) {
      files.forEach(function(rp) {
        var error2, file, gl, ol, stat;
        if (rp[0] === '/') {
          file = path.resolve(rp);
        } else {
          file = path.join(p, rp);
        }
        try {
          stat = fs.lstatSync(file);
          ol = ownerName(stat).length;
          gl = groupName(stat).length;
          if (ol > stats.maxOwnerLength) {
            stats.maxOwnerLength = ol;
          }
          if (gl > stats.maxGroupLength) {
            return stats.maxGroupLength = gl;
          }
        } catch (error2) {

        }
      });
    }
    files.forEach(function(rp) {
      var error2, ext, file, groupColor, grp, link, lstat, name, own, ownerColor, s, stat;
      if (rp[0] === '/') {
        file = path.resolve(rp);
      } else {
        file = path.join(p, rp);
      }
      try {
        lstat = fs.lstatSync(file);
        link = lstat.isSymbolicLink();
        stat = link && fs.statSync(file) || lstat;
      } catch (error2) {
        if (link) {
          stat = lstat;
          stats.brokenLinks.push(file);
        } else {
          log_error('can\'t read file:', file, link);
          return;
        }
      }
      ext = path.extname(file).substr(1);
      name = path.basename(file, path.extname(file));
      if (name[0] === '.') {
        ext = name.substr(1) + path.extname(file);
        name = '';
      }
      if (name.length || args.all) {
        own = ownerName(stat);
        grp = groupName(stat);
        ownerColor = colors['_users'][own];
        if (!ownerColor) {
          ownerColor = colors['_users']['default'];
        }
        groupColor = colors['_groups'][grp];
        if (!groupColor) {
          groupColor = colors['_groups']['default'];
        }
        s = "";
        if (args.rights) {
          s += rightsString(stat, ownerColor, groupColor);
          s += " ";
        }
        if (args.owner) {
          s += ownerString(stat, ownerColor, groupColor);
          s += " ";
        }
        if (args.bytes) {
          s += sizeString(stat);
        }
        if (args.mdate) {
          s += timeString(stat);
        }
        if (stat.isDirectory()) {
          if (!args.files) {
            s += dirString(name, ext);
            if (link) {
              s += linkString(file);
            }
            dirs.push(s + reset);
            if (args.alphabetical) {
              alph.push(s + reset);
            }
            dsts.push(stat);
            return stats.num_dirs += 1;
          } else {
            return stats.hidden_dirs += 1;
          }
        } else {
          if (!args.dirs) {
            s += nameString(name, ext);
            if (ext) {
              s += extString(ext);
            }
            if (link) {
              s += linkString(file);
            }
            fils.push(s + reset);
            if (args.alphabetical) {
              alph.push(s + reset);
            }
            fsts.push(stat);
            exts.push(ext);
            return stats.num_files += 1;
          } else {
            return stats.hidden_files += 1;
          }
        }
      } else {
        if (stat.isFile()) {
          return stats.hidden_files += 1;
        } else if (stat.isDirectory()) {
          return stats.hidden_dirs += 1;
        }
      }
    });
    if (args.size || args.kind || args.time) {
      if (dirs.length && !args.files) {
        dirs = sort(dirs, dsts);
      }
      if (fils.length) {
        fils = sort(fils, fsts, exts);
      }
    }
    if (args.alphabetical) {
      results = [];
      for (j = 0, len = alph.length; j < len; j++) {
        p = alph[j];
        results.push(log(p));
      }
      return results;
    } else {
      for (k = 0, len1 = dirs.length; k < len1; k++) {
        d = dirs[k];
        log(d);
      }
      results1 = [];
      for (m = 0, len2 = fils.length; m < len2; m++) {
        f = fils[m];
        results1.push(log(f));
      }
      return results1;
    }
  };

  listDir = function(p) {
    var error, error2, files, j, len, msg, pn, pr, ps, ref1, results, s, sp;
    ps = p;
    try {
      files = fs.readdirSync(p);
    } catch (error2) {
      error = error2;
      msg = error.message;
      if (_s.startsWith(msg, "EACCES")) {
        msg = "permission denied";
      }
      log_error(msg);
    }
    if (args.find) {
      files = files.filter(function(f) {
        if (RegExp(args.find).test(f)) {
          return f;
        }
      });
    }
    if (args.find && !files.length) {
      true;
    } else if (args.paths.length === 1 && args.paths[0] === '.' && !args.recurse) {
      log(reset);
    } else {
      s = colors['_arrow'] + "â–º" + colors['_header'][0] + " ";
      if (ps[0] !== '~') {
        ps = path.resolve(ps);
      }
      if (_s.startsWith(ps, process.env.PWD)) {
        ps = "./" + ps.substr(process.env.PWD.length);
      } else if (_s.startsWith(p, process.env.HOME)) {
        ps = "~" + p.substr(process.env.HOME.length);
      }
      if (ps === '/') {
        s += '/';
      } else {
        sp = ps.split('/');
        s += colors['_header'][0] + sp.shift();
        while (sp.length) {
          pn = sp.shift();
          if (pn) {
            s += colors['_header'][1] + '/';
            s += colors['_header'][sp.length === 0 && 2 || 0] + pn;
          }
        }
      }
      log(reset);
      log(s + " " + reset);
      log(reset);
    }
    if (files.length) {
      listFiles(p, files);
    }
    if (args.recurse) {
      ref1 = fs.readdirSync(p).filter(function(f) {
        return fs.lstatSync(path.join(p, f)).isDirectory();
      });
      results = [];
      for (j = 0, len = ref1.length; j < len; j++) {
        pr = ref1[j];
        results.push(listDir(path.resolve(path.join(p, pr))));
      }
      return results;
    }
  };

  pathstats = args.paths.map(function(f) {
    var error, error2;
    try {
      return [f, fs.statSync(f)];
    } catch (error2) {
      error = error2;
      log_error('no such file: ', f);
      return [];
    }
  });

  filestats = pathstats.filter(function(f) {
    return f.length && !f[1].isDirectory();
  });

  if (filestats.length > 0) {
    log(reset);
    listFiles(process.cwd(), filestats.map(function(s) {
      return s[0];
    }));
  }

  ref1 = pathstats.filter(function(f) {
    return f.length && f[1].isDirectory();
  });
  for (j = 0, len = ref1.length; j < len; j++) {
    p = ref1[j];
    listDir(p[0]);
  }

  if (args.stats) {
    sprintf = require("sprintf-js").sprintf;
    log(BW(1) + " " + fw(15) + stats.num_dirs + (stats.hidden_dirs && fw(10) + "+" + fw(12) + stats.hidden_dirs || "") + fw(10) + " dirs " + fw(15) + stats.num_files + (stats.hidden_files && fw(10) + "+" + fw(12) + stats.hidden_files || "") + fw(10) + " files " + fw(15) + sprintf("%2.1f", prof('end', 'ls')) + fw(10) + " ms" + " " + reset);
  }

}).call(this);
